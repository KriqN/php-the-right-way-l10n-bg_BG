---
title: Бази данни
---

# Бази данни

Много пъти вашият PHP код ще ползва база от данни за да записва информацията. Имате няколко избора за свързване и работа с вашата база данни. Препоръчителната опция _до PHP 5.1.0_ беше да се ползват естествените разширения [mysql][mysql], [mysqli][mysqli], [pgsql][pgsql] и др.

Естествените драйвери са страхотни, ако ползвате само ЕДНА база данни в вашето приложение, но ако например ползвате MySQL и малко MSSQL,
или имате нужда да се свържете с база от данни на Oracle, тогава няма да имате взможността да ползвате едни и същи драйвери. Ще трябва да се запознаете с чисто ново API за всяка един тип база от данни &mdash; и това може да създаде много проблеми.

Допълнителна бележка към естествените драйвери: _mysql_ разширението за PHP вече не се разработва активно, и официалното състояние в версия PHP 5.4.0 е
"В дълъг процес на премахване". Това означава че ще бъде премахнат в следващите няколко версии, т.е. до PHP 5.6 (или което идва след 5.5) може би вече няма да го има. Ако ползвате `mysql_connect()` и `mysql_query()` във вашите приложения, тогава ще трябва да ги пренапишете по някое време, като
най-доброто решение е да заместите ползването на mysql с mysqli или PDO още по време на процеса на разработа за да не се налага да бързате впоследствие.
_Ако започвате от начало, то тогава изобщо не трябва да ползвате разширението mysql: ползвайте [MySQLi extension][mysqli] или PDO._

* [PHP: Избор на API за MySQL](http://php.net/manual/en/mysqlinfo.api.choosing.php)

## PDO

PDO е библиотека за абстрация на връзката с база данни &mdash; вградена в PHP от версия 5.1.0 &mdash; която предоставя общ интерфейс за работа
с много различни бази от данни. PDO не превежда/транслира вашите заявки и не емулира липсващи възможности, та служи само за свързване с
множество типове разлини бази от данни изпозлвайки общо API.


По-важно, `PDO` ти позволява да безопасно да вкарваш външен вход (параметри, подадени от потребителя) в SQL заявките без да се притесняваш от SQL injection.
Това е възможно чрез параметризирани заявки (PDO statement) и обвързани параметри (bound parameters).


Нека предположим, че PHP скрипт получава числово ID като параметър на заявката. Това ID трябва да се използва за извличането на потребителски запис от базата. Това е `грешният начин` да постигнете това:

{% highlight php %}
<?php
$pdo = new PDO('sqlite:users.db');
$pdo->query("SELECT name FROM users WHERE id = " . $_GET['id']); // <-- NO!
{% endhighlight %}

Този код е ужасен. Така вие вкарвате суров параметър в заявката. По този начин ще бъдете хакнати за нула време. Просто си представете как хакер предава `id` параметър като изпозлва URL подобен на
`http://example.com/?id=1%3BDELETE+FROM+users`.  Това ще зададе `$_GET['id']` стойност `id=1;DELETE FROM users`
което ще изтрие всички ваши потребители! Вместо това, вие трябва да филтрирате ID-то от входа, изпозлваки PDO обвързани параметри (bound parameters).


{% highlight php %}
<?php
$pdo = new PDO('sqlite:users.db');
$stmt = $pdo->prepare('SELECT name FROM users WHERE id = :id');
$stmt->bindParam(':id', $_GET['id'], PDO::PARAM_INT); //<-- Automatically sanitized by PDO
$stmt->execute();
{% endhighlight %}

Това е правилният начин. Използва обвързан параметър към PDO параметризирана заявка. Това екранира външния вход за ID преди да бъде предаден на базата данни и предотвратява SQL injection.

* [Научи повече за PDO][1]


Трябва също да знаете, че връзките към базата данни използват ресурси и е имало проблеми с липса на достатъчно ресурси,
когато не се затварят връзки към базата данни или заявки, но това е по-често за другите програмни езици. Изпозлването на

PDO може неуказано да затвори възка, при унищожаването на обект за да осигури всички синоними (референции) на обекта да са изтрити,
т.е. със стойност NULL.  Ако не направите това изрично, PHP автоматично ще затвори връзката, когато скрипта приключи,
освен ако не ползвате постоянни връзки (persistent connections).

* [Научи повече за PDO връзките][5]

## Слоеве на абстракция

Много рамки ползват обствен слой на абстракция, който може или не може да бъде надграден върху PDO. Те обикновено емулират възможности на
на други бази, които са достъпни за едни, но не и за други, като обвиват заявките в PHP методи, давайки реална абстракция на базата данни.
Това естествено добавя малко режиен (overhead), но ако разработвате преносимо (съвместимо с множество платформи) приложение,
което трябва да работи с MySQL, PostgreSQL и SQLite, тогава малко (най-често незабележимо) забавяне ще си струва за сметка на
подредения и чист код.

Някои слоеве на абстракция са направени в съответствие с PSR-0 конвенцията на пространства от имена и могат да бъдат инсталирани в приложението ви, примери:

* [Doctrine2 DBAL][2]
* [ZF2 Db][4]
* [ZF1 Db][3]

[1]: http://www.php.net/manual/en/book.pdo.php
[2]: http://www.doctrine-project.org/projects/dbal.html
[3]: http://framework.zend.com/manual/en/zend.db.html
[4]: http://packages.zendframework.com/docs/latest/manual/en/index.html#zend-db
[5]: http://php.net/manual/en/pdo.connections.php

[mysql]: http://php.net/mysql
[mysqli]: http://php.net/mysqli
[pgsql]: http://php.net/pgsql
